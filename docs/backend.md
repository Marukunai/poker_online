# Documentaci√≥n del Backend - Poker Online ‚ô¶Ô∏è

## üè† Introducci√≥n

Este proyecto representa el backend de una aplicaci√≥n web y m√≥vil de p√≥ker en l√≠nea, dise√±ado como proyecto de autoaprendizaje y desarrollo. El objetivo es ofrecer una experiencia de p√≥ker realista y multijugador, con autenticaci√≥n segura, gesti√≥n de partidas, apuestas, l√≥gica de juego, y una futura interfaz frontend.

---

## üìÇ Estructura del proyecto

```
/poker-online
‚îú‚îÄ‚îÄ backend/                           # Proyecto Spring Boot (Java)
‚îÇ   ‚îú‚îÄ‚îÄ controller/                    # Controladores REST
‚îÇ   ‚îú‚îÄ‚îÄ service/                       # L√≥gica de negocio
‚îÇ   ‚îú‚îÄ‚îÄ model/                         # Entidades JPA (User, Mesa, Turno...)
‚îÇ   ‚îú‚îÄ‚îÄ dto/                           # Objetos de transferencia de datos
‚îÇ   ‚îú‚îÄ‚îÄ repository/                    # Repositorios JPA
‚îÇ   ‚îú‚îÄ‚îÄ config/                        # Seguridad JWT y configuraciones
‚îÇ   ‚îú‚îÄ‚îÄ PokerBackendApplication.java   # Clase principal
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ docs/                              # Documentaci√≥n Markdown (GitHub Pages)
‚îÇ   ‚îú‚îÄ‚îÄ index.md           
‚îÇ   ‚îú‚îÄ‚îÄ backend.md                     # Esta documentaci√≥n
‚îÇ   ‚îî‚îÄ‚îÄ frontend.md                    # Documentaci√≥n para el frontend (a√∫n no implementado)
‚îî‚îÄ‚îÄ frontend/                          # (Futuro) Frontend React/Flutter
```

---

## üéØ Tecnolog√≠as utilizadas

* **Java 17** + Spring Boot 3
* **JWT** para autenticaci√≥n segura
* **Hibernate/JPA** para persistencia
* **MySQL** como base de datos
* **WebSocket** para comunicaci√≥n en tiempo real (turnos, acciones)
* **Postman** para pruebas

---

# Inicio de aplicativo

Antes de poder usar la aplicaci√≥n, primero debemos asegurarnos de tener una base de datos como la que definimos en [application.properties](https://github.com/Marukunai/poker_online/blob/b7ef2a663bd3bd4e3464f558dc1fbf55f85a7347/poker-backend/src/main/resources/application.properties).

Si no la tienes creada, puedes ejecutarla desde el mismo archivo [docker-compose.yml](), o bien:

## 1. üê¨ Iniciar la base de datos MySQL

Debes tener un contenedor Docker corriendo con MySQL (versi√≥n 8.0) y con la configuraci√≥n adecuada (nombre de base de datos, usuario, contrase√±a).

Puedes usar el siguiente comando si no tienes uno creado:

```bash
docker run --name mysql_poker -e MYSQL_ROOT_PASSWORD=root -e MYSQL_DATABASE=poker -e MYSQL_USER=user -e MYSQL_PASSWORD=pass -p 3306:3306 -d mysql:8.0
```

Acto seguido, y una vez la BD quede bien iniciada (comprobaremos que tenemos un contenedor creado llamado mysql_poker) usando los siguientes comandos:

```bash
docker ps #para comprobar que est√° creado
```

Deber√≠a salir algo as√≠:

```commandline
CONTAINER ID   IMAGE       COMMAND                  CREATED          STATUS          PORTS                               NAMES
............   mysql:8.0   "docker-entrypoint.s‚Ä¶"   .. minutes ago   Up .. minutes   0.0.0.0:3306->3306/tcp, 33060/tcp   mysql_poker
```

## 2. ‚öôÔ∏è Configurar el proyecto backend

Requisitos previos:

- Tener instalado Java 17+
- Tener instalado Gradle o usar el wrapper (./gradlew)
- Tener un IDE (recomendado: IntelliJ IDEA, VSCode o Eclipse)

### Clonar el repositorio

```bash
git clone https://github.com/Marukunai/poker_online.git
```

Verificar el archivo [application.properties](https://github.com/Marukunai/poker_online/blob/b7ef2a663bd3bd4e3464f558dc1fbf55f85a7347/poker-backend/src/main/resources/application.properties).

Aseg√∫rate de que coincide con la configuraci√≥n de tu base de datos:

```properties
spring.datasource.url=jdbc:mysql://localhost:3306/pokerdb
spring.datasource.username=user
spring.datasource.password=jupiter*
spring.jpa.hibernate.ddl-auto=update
```

## 3. üöÄ Ejecutar el backend

- Opci√≥n A: Desde l√≠nea de comandos
   
```bash
cd poker_online/poker-backend
./gradlew bootRun
```

- Opci√≥n B: Desde IntelliJ / Eclipse:

   Importa el proyecto como proyecto Gradle.

   Aseg√∫rate de que se descarguen las dependencias (build.gradle).

   Ejecuta la clase [PokerBackendApplication.java](https://github.com/Marukunai/poker_online/blob/d871505914e044997bb40eae389340226ac6049c/poker-backend/src/main/java/com/pokeronline/PokerBackendApplication.java).

## 4. üì¶ Probar que est√° funcionando

Abre tu navegador y accede a:

```bash
http://localhost:8080/api/mesas
```

Deber√≠as ver una lista de mesas (o un array vac√≠o si no hay mesas creadas a√∫n).

Tambi√©n puedes probar con Postman usando las rutas documentadas en el backend.

## üîë Autenticaci√≥n JWT

Los usuarios se autentican mediante login con correo y contrase√±a, obteniendo un token JWT. Este token se adjunta en las peticiones posteriores como:

```http
Authorization: Bearer {token}
```

---

## üé¨ Flujo general de una partida de p√≥ker

1. üîë **Registro/Login**
2. üìç **Uni√≥n a una mesa** (`/api/mesas/unirse/{mesaId}`)
3. ‚ñ∂Ô∏è **Inicio de la partida** (`/api/turnos/iniciar/{mesaId}`)
4. ‚ô¶Ô∏è **Reparto de cartas privadas** (`BarajaService` lo gestiona)
5. ‚è≥ **Turnos de acci√≥n** (check, fold, call, raise...)
6. üìä **Avance de fases** (`/api/turnos/fase/{mesaId}/siguiente`)

    * Pre-Flop ‚Üí Flop ‚Üí Turn ‚Üí River ‚Üí Showdown
7. ‚öñÔ∏è **Evaluaci√≥n de manos** (`EvaluadorManoService`)
8. üåü **Reparto del pot** (`MesaService`, incluyendo side pots)
9. ‚ü≥ **Inicio de nueva ronda**

---

## üìë Endpoints destacados (Turnos)

### üöÄ Iniciar turnos

```http
POST /api/turnos/iniciar/{mesaId}
```

* Inicializa la baraja, reparte cartas y prepara la primera ronda

### ‚è±Ô∏è Ver turno actual

```http
GET /api/turnos/actual/{mesaId}
```

* Devuelve el `Turno` activo actualmente

### ‚û°Ô∏è Avanzar turno

```http
POST /api/turnos/avanzar/{mesaId}
```

* Desactiva el turno actual y activa el siguiente disponible

### üèõÔ∏è Realizar acci√≥n

```http
POST /api/turnos/accion/{mesaId}?accion=RAISE&cantidad=50
Authorization: Bearer {token}
```

* Acciones: `FOLD`, `CHECK`, `CALL`, `RAISE`, `ALL_IN`
* Valida fichas, apuestas m√≠nimas, y avanza el turno

### üîÑ Avanzar fase

```http
POST /api/turnos/fase/{mesaId}/siguiente
```

* Cambia a la siguiente fase y reparte cartas comunitarias si corresponde

---

## üèÜ Roles en mesa

* Dealer
* Small Blind
* Big Blind
* Jugadores normales

> Actualmente los roles se asignan al iniciar partida y podr√°n rotar en futuras versiones.

---

## ‚ö° Control de fichas

* `User.fichas`: fichas globales del usuario
* `UserMesa.fichasEnMesa`: fichas con las que entra a la mesa
* `UserMesa.totalApostado`: lo que ha puesto en la partida actual
* `Mesa.pot`: bote total en juego

---

## üöÄ Nuevas funcionalidades implementadas

### üß† Jugadores controlados por IA (bots)

Se ha a√±adido soporte para a√±adir bots en partidas privadas:

- Los bots se representan como `User` con `esIA = true`.
- Se crean din√°micamente con nombres √∫nicos como `CPU-32`.
- S√≥lo pueden a√±adirse en mesas privadas.
- Ignorados al calcular fichas globales (`User.fichas`).

### üîí Mesas privadas

Ahora es posible crear mesas privadas con:

- C√≥digo de acceso personalizado (para invitar amigos).
- Fichas **temporales**, no afectando el saldo global del usuario.
- Soporte para hasta 8 jugadores.

#### Endpoints:

```http
POST /api/mesas/privadas/crear
```

Par√°metros: nombre, maxJugadores, c√≥digo, fichasTemporales, smallBlind, bigBlind

```http
POST /api/mesas/privadas/unirse
```

Par√°metros: email, c√≥digoAcceso, fichasSolicitadas

```http
POST /api/mesas/privadas/{codigo}/add-bot
```

A√±ade un bot a la mesa privada.

### ‚ö†Ô∏è Reglas de fichas temporales

- M√°ximo: 10 millones por jugador.
- No se guardan en `User.fichas`.
- Se eliminan al salir de la mesa.

---

## üîÑ Mejoras internas

- Se impide unirse a varias mesas a la vez (se desconecta de la anterior).
- `DataLoader` m√°s completo con 6 usuarios, 3 mesas realistas, fichas variadas.
- IA ignorada en l√≥gica de ranking, fichas, pot.
- Control reforzado en uniones a mesa (si ya est√° unido, no lo vuelve a hacer).

---

## üß† Jugadores controlados por IA (bots)

Los bots ahora tienen un comportamiento avanzado y realista, incluyendo decisiones estrat√©gicas, estilo de juego, y simulaci√≥n de chat.

### üîß Caracter√≠sticas principales

- Representados como objetos `User` con `esIA = true`.
- Solo pueden a√±adirse a **mesas privadas**.
- Act√∫an autom√°ticamente cuando les llega el turno, con un **retardo de 10-15 segundos** simulando "pensamiento".

```java
User bot = User.builder()
  .email("cpu...@bot.com")
  .username("CPU-XX")
  .esIA(true)
  .nivelBot(DificultadBot.NORMAL) // FACIL, NORMAL, DIFICIL
  .estiloBot(EstiloBot.AGRESIVO)  // AGRESIVO, CONSERVADOR, LOOSE, TIGHT, DEFAULT
  .build();
```

### üéöÔ∏è Dificultad y estilo de juego

Los bots toman decisiones en base a su nivel de dificultad (`FACIL`, `NORMAL`, `DIFICIL`) y su estilo (`AGRESIVO`, `CONSERVADOR`, `LOOSE`, `TIGHT`, `DEFAULT`):

| Nivel     | Bluff | Slowplay | Evaluaci√≥n contextual        |
|-----------|-------|----------|------------------------------|
| FACIL     | ‚ùå    | ‚ùå       | Decisiones simples           |
| NORMAL    | ‚ö†Ô∏è     | ‚ùå       | Usa draws y conectadas       |
| DIFICIL   | ‚úÖ    | ‚úÖ       | Analiza fuerza + faroles     |

| Estilo       | Agresividad | Comportamiento                        |
|--------------|-------------|--------------------------------------|
| AGRESIVO     | Alto (1.4x) | Muchos raise y all-in                |
| CONSERVADOR  | Bajo (0.7x) | Cauto, se retira con facilidad       |
| LOOSE        | Medio (1.2x)| Juega muchas manos                   |
| TIGHT        | Medio (0.8x)| Solo juega manos fuertes             |
| DEFAULT      | 1.0x        | Equilibrado                          |

Los bots ajustan sus decisiones con una mezcla de:

- **Fuerza de la mano evaluada**
- **Conectividad y suited**
- **Flush/Straight draw**
- **Probabilidad de bluff o slowplay seg√∫n dificultad**

### üí¨ Frases simuladas por WebSocket

Cada vez que un bot act√∫a, puede enviar una frase simulada en el chat, seg√∫n su acci√≥n y estilo:

```json
{
  "jugador": "CPU-42",
  "mensaje": "¬°A ver si aguantas esta!"
}
```

Estas frases se gestionan mediante el enum `FrasesBotChat.java`.

---

### üìõ L√≥gica de control y reglas

- Solo el **creador de la mesa** puede a√±adir bots.
- El n√∫mero de bots se limita por el `maxJugadores` de la mesa.
    - Si hay 6 plazas y ya hay 4 humanos, s√≥lo se pueden a√±adir 2 bots.
    - Si un humano se une y la mesa est√° llena, se elimina autom√°ticamente un bot.
- Los bots **no afectan** el saldo global (`User.fichas`) y usan **fichas temporales** (`UserMesa.fichasEnMesa`).
- Bots eliminados si abandonan mesa o se reemplazan por humanos.

---

## üì¶ Pruebas y depuraci√≥n

Los endpoints nuevos pueden probarse v√≠a Postman:

- Crear mesa privada.
- Unirse con fichas temporales.
- A√±adir CPU bots.
- Validar que no afecta al saldo global.

---

## üèÜ Pr√≥ximas funcionalidades

- [ ] Reloj de turnos visual (UI)
- [ ] Modo espectador (join sin jugar)
- [ ] Sistema de chat in-game
- [ ] Clasificaci√≥n de jugadores (ranking, torneos)
- [ ] IA con decisiones de juego (fold, call, raise)

---

## üß™ Testing sugerido

- Crear mesa privada con contrase√±a.
- A√±adir 1‚Äì2 jugadores reales.
- A√±adir bots.
- Iniciar partida y observar comportamiento.
- Verificar que el `User.fichas` no cambia tras salir.

---

## üßæ Notas finales

Estas funcionalidades buscan permitir un entorno de juego m√°s flexible y justo entre amigos o entornos cerrados, sin comprometer la econom√≠a interna del sistema.

Puedes consultar la evoluci√≥n de esta l√≥gica dentro del paquete `service/`, especialmente en:

- `MesaPrivadaService`
- `UserMesaService`
- `MesaService`
- `TurnoService`

--- 

## FUNCIONALIDADES YA IMPLEMENTADAS

- ‚úîÔ∏è L√≥gica completa de poker por rondas: Pre-flop, Flop, Turn, River.

- ‚úîÔ∏è Evaluaci√≥n real de manos (EvaluadorManoService) incluyendo desempates.

- ‚úîÔ∏è Reparto proporcional de bote (incluyendo empates).

- ‚úîÔ∏è Bots con IA realista:
  - Dificultades (F√ÅCIL, NORMAL, DIF√çCIL).
  - Estilos de juego (AGRESIVO, CONSERVADOR, LOOSE, TIGHT, DEFAULT). 
  - Bluff, slowplay, chat simulado.

- ‚úîÔ∏è L√≥gica de decisiones de bot seg√∫n mano, fase y contexto.

- ‚úîÔ∏è Chat del bot v√≠a WebSocket (FrasesBotChat, integraci√≥n en BotService).

- ‚úîÔ∏è Restricciones en n√∫mero de bots (y reemplazo si mesa llena).

- ‚úîÔ∏è Registro de acciones (AccionPartida).

- ‚úîÔ∏è Control de fichas globales vs. fichas en mesa.

- ‚úîÔ∏è WebSocket en todas las acciones relevantes.

- ‚úîÔ∏è Control total de las partidas privadas: acceso, uniones, bots, fichas temporales.

---

## ü™ß Tareas futuras (Backend)

* [ ] Estad√≠sticas por jugador:
  - % de manos ganadas. 
  - Veces que hizo bluff. 
  - Veces que fue all-in. 
  - Fichas ganadas totales.
  
* [ ] Modo Espectador
* [ ] Torneos o partidas clasificatorias (ranking)

---

## üìÖ Historial de manos

Cada showdown se guarda por jugador:

* Cartas que ten√≠a
* Mano ganadora
* Fase final
* Fecha y hora
* Fichas ganadas o perdidas

Esto permite un an√°lisis post-partida o ranking general.

---

## üîß WebSocket (eventos en tiempo real)

Eventos enviados desde servidor a mesa:

* `turno`: nuevo jugador en turno
* `accion`: acci√≥n tomada
* `fase`: cambio de fase
* `ganador`: resultado final

---

## üíº Consideraciones de despliegue

* Recomendado para hosting: **Render**, **Railway**, **Heroku (Java)**
* DB externa: PlanetScale o Amazon RDS
* Variables de entorno para `JWT_SECRET`, `DB_URL`, etc.

Actualmente, se utiliza una BD personal para pruebas. Una vez est√© el proyecto terminado, se probar√° de trasladarlo a una BD global para hosting.

---

## üìö Cr√©ditos y colaboraci√≥n

Este proyecto ha sido desarrollado por [**Marc Mart√≠n**](https://x.com/marukunai_03).

> Si deseas colaborar o extender la l√≥gica, puedes abrir un `Pull Request` o contactar v√≠a GitHub Issues.

---

## üîñ Licencia

MIT License. Libre uso con cr√©dito al autor original.